import React from 'react';
import { Heart, Zap, TrendingUp } from 'lucide-react';

const DungeonDescent = () => {
  const [gameState, setGameState] = React.useState('menu');
  const [score, setScore] = React.useState(0);
  const [floor, setFloor] = React.useState(1);
  
  const canvasRef = React.useRef(null);
  const gameRef = React.useRef({
    player: { x: 400, y: 300, hp: 6, maxHp: 6, speed: 3, damage: 1, fireRate: 15, size: 20, tears: [], powerups: [], dashCooldown: 0, dashing: 0 },
    enemies: [],
    items: [],
    particles: [],
    room: { cleared: false, type: 'normal', doorOpen: false },
    keys: {},
    frame: 0,
    cooldown: 0,
    shake: 0,
    bossDefeated: false,
    shootDir: { x: 0, y: -1 }
  });

  const POWERUPS = {
    health: { name: 'Sacred Heart', color: '#ff6b9d', effect: (p) => { p.maxHp += 2; p.hp = p.maxHp; } },
    damage: { name: 'Pentagram', color: '#ff4444', effect: (p) => p.damage += 0.5 },
    speed: { name: 'Speed Boots', color: '#44ff44', effect: (p) => p.speed += 0.8 },
    fireRate: { name: 'Wire Hanger', color: '#ffaa44', effect: (p) => p.fireRate = Math.max(5, p.fireRate - 3) },
    triple: { name: 'Triple Shot', color: '#4444ff', effect: (p) => p.powerups.push('triple') }
  };

  const generateRoom = React.useCallback((type = 'normal') => {
    const g = gameRef.current;
    g.enemies = [];
    g.items = [];
    g.room = { cleared: false, type, doorOpen: false };
    g.bossDefeated = false;

    if (type === 'boss') {
      g.enemies.push({
        x: 400, y: 200, hp: 30 + floor * 10, maxHp: 30 + floor * 10,
        speed: 1, size: 50, type: 'boss', phase: 1,
        attackCooldown: 0, pattern: 0
      });
    } else {
      const count = 3 + Math.floor(floor * 1.5);
      for (let i = 0; i < count; i++) {
        const type = Math.random() < 0.7 ? 'basic' : Math.random() < 0.5 ? 'fast' : 'tank';
        g.enemies.push({
          x: 150 + Math.random() * 500,
          y: 100 + Math.random() * 300,
          hp: type === 'tank' ? 4 : type === 'fast' ? 2 : 3,
          speed: type === 'fast' ? 2 : type === 'tank' ? 0.8 : 1.2,
          size: type === 'tank' ? 25 : type === 'fast' ? 12 : 18,
          type
        });
      }
    }
  }, [floor]);

  const shoot = React.useCallback((dir) => {
    const g = gameRef.current;
    if (g.cooldown > 0) return;
    
    g.cooldown = g.player.fireRate;
    g.shootDir = dir;

    const tears = [{ dx: dir.x, dy: dir.y }];
    
    if (g.player.powerups.includes('triple')) {
      const angle = Math.atan2(dir.y, dir.x);
      tears.push(
        { dx: Math.cos(angle - 0.3), dy: Math.sin(angle - 0.3) },
        { dx: Math.cos(angle + 0.3), dy: Math.sin(angle + 0.3) }
      );
    }

    tears.forEach(t => {
      g.player.tears.push({
        x: g.player.x,
        y: g.player.y,
        dx: t.dx * 6,
        dy: t.dy * 6,
        damage: g.player.damage,
        size: 8
      });
    });
  }, []);

  React.useEffect(() => {
    if (gameState !== 'playing') return;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const g = gameRef.current;

    const handleKeyDown = (e) => {
      g.keys[e.key.toLowerCase()] = true;
      
      if (e.key === 'ArrowUp') shoot({ x: 0, y: -1 });
      if (e.key === 'ArrowDown') shoot({ x: 0, y: 1 });
      if (e.key === 'ArrowLeft') shoot({ x: -1, y: 0 });
      if (e.key === 'ArrowRight') shoot({ x: 1, y: 0 });
      
      // Dash mechanic
      if (e.key === ' ' && g.player.dashCooldown === 0) {
        let dashDx = 0, dashDy = 0;
        if (g.keys['w']) dashDy -= 1;
        if (g.keys['s']) dashDy += 1;
        if (g.keys['a']) dashDx -= 1;
        if (g.keys['d']) dashDx += 1;
        
        if (dashDx !== 0 || dashDy !== 0) {
          const mag = Math.sqrt(dashDx * dashDx + dashDy * dashDy);
          g.player.dashing = 10;
          g.player.dashCooldown = 60;
          g.player.dashDir = { x: dashDx / mag, y: dashDy / mag };
        }
      }
    };

    const handleKeyUp = (e) => {
      g.keys[e.key.toLowerCase()] = false;
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    const gameLoop = () => {
      g.frame++;
      if (g.cooldown > 0) g.cooldown--;
      if (g.shake > 0) g.shake--;
      if (g.player.dashCooldown > 0) g.player.dashCooldown--;
      if (g.player.dashing > 0) g.player.dashing--;

      // Player movement
      let dx = 0, dy = 0;
      
      if (g.player.dashing > 0) {
        // Dash movement
        dx = g.player.dashDir.x;
        dy = g.player.dashDir.y;
        g.player.x += dx * 15;
        g.player.y += dy * 15;
        
        // Dash particles
        g.particles.push({
          x: g.player.x,
          y: g.player.y,
          dx: (Math.random() - 0.5) * 2,
          dy: (Math.random() - 0.5) * 2,
          life: 15,
          color: '#ffeeaa'
        });
      } else {
        // Normal movement
        if (g.keys['w']) dy -= 1;
        if (g.keys['s']) dy += 1;
        if (g.keys['a']) dx -= 1;
        if (g.keys['d']) dx += 1;
        
        if (dx !== 0 || dy !== 0) {
          const mag = Math.sqrt(dx * dx + dy * dy);
          g.player.x += (dx / mag) * g.player.speed;
          g.player.y += (dy / mag) * g.player.speed;
        }
      }
      
      g.player.x = Math.max(30, Math.min(770, g.player.x));
      g.player.y = Math.max(30, Math.min(570, g.player.y));

      // Update tears
      g.player.tears = g.player.tears.filter(t => {
        t.x += t.dx;
        t.y += t.dy;
        return t.x > 0 && t.x < 800 && t.y > 0 && t.y < 600;
      });

      // Update enemies
      g.enemies.forEach(e => {
        if (e.type === 'boss') {
          e.attackCooldown--;
          
          if (e.attackCooldown <= 0) {
            e.pattern = (e.pattern + 1) % 3;
            e.attackCooldown = 90;
            
            if (e.pattern === 0) {
              for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                g.enemies.push({
                  x: e.x, y: e.y, hp: 2, speed: 0,
                  size: 10, type: 'projectile',
                  dx: Math.cos(angle) * 3, dy: Math.sin(angle) * 3
                });
              }
            }
          }

          const dx = g.player.x - e.x;
          const dy = g.player.y - e.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist > 100) {
            e.x += (dx / dist) * e.speed;
            e.y += (dy / dist) * e.speed;
          }
        } else if (e.type === 'projectile') {
          e.x += e.dx;
          e.y += e.dy;
        } else {
          const dx = g.player.x - e.x;
          const dy = g.player.y - e.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist > 0) {
            e.x += (dx / dist) * e.speed;
            e.y += (dy / dist) * e.speed;
          }
        }

        // Enemy collision with player
        const pdx = g.player.x - e.x;
        const pdy = g.player.y - e.y;
        const pdist = Math.sqrt(pdx * pdx + pdy * pdy);
        
        if (pdist < g.player.size + e.size && g.frame % 30 === 0 && g.player.dashing === 0) {
          g.player.hp--;
          g.shake = 10;
          if (g.player.hp <= 0) {
            setGameState('gameover');
          }
        }
      });

      // Tear collision
      g.player.tears.forEach((t, ti) => {
        g.enemies.forEach((e, ei) => {
          const dx = t.x - e.x;
          const dy = t.y - e.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < e.size + t.size) {
            e.hp -= t.damage;
            g.player.tears.splice(ti, 1);
            
            for (let i = 0; i < 5; i++) {
              g.particles.push({
                x: e.x, y: e.y,
                dx: (Math.random() - 0.5) * 4,
                dy: (Math.random() - 0.5) * 4,
                life: 20,
                color: '#ff4444'
              });
            }
            
            if (e.hp <= 0) {
              g.enemies.splice(ei, 1);
              setScore(s => s + (e.type === 'boss' ? 500 : 50));
              
              if (e.type === 'boss') {
                g.bossDefeated = true;
                g.room.doorOpen = true;
              }
              
              if (Math.random() < 0.15 && e.type !== 'projectile') {
                const types = Object.keys(POWERUPS);
                const type = types[Math.floor(Math.random() * types.length)];
                g.items.push({ x: e.x, y: e.y, type, collected: false });
              }
            }
          }
        });
      });

      // Update particles
      g.particles = g.particles.filter(p => {
        p.x += p.dx;
        p.y += p.dy;
        p.life--;
        return p.life > 0;
      });

      // Item collection
      g.items.forEach(item => {
        const dx = g.player.x - item.x;
        const dy = g.player.y - item.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < 30 && !item.collected) {
          item.collected = true;
          POWERUPS[item.type].effect(g.player);
          
          for (let i = 0; i < 10; i++) {
            g.particles.push({
              x: item.x, y: item.y,
              dx: (Math.random() - 0.5) * 5,
              dy: (Math.random() - 0.5) * 5,
              life: 30,
              color: POWERUPS[item.type].color
            });
          }
        }
      });

      // Check room clear
      if (!g.room.cleared && g.enemies.length === 0 && g.room.type !== 'boss') {
        g.room.cleared = true;
        g.room.doorOpen = true;
      }

      // Draw
      ctx.fillStyle = '#1a0f1f';
      ctx.fillRect(0, 0, 800, 600);

      // Shake effect
      if (g.shake > 0) {
        ctx.save();
        ctx.translate((Math.random() - 0.5) * g.shake, (Math.random() - 0.5) * g.shake);
      }

      // Draw floor
      ctx.strokeStyle = '#2a1f2f';
      ctx.lineWidth = 2;
      for (let i = 0; i < 800; i += 40) {
        for (let j = 0; j < 600; j += 40) {
          ctx.strokeRect(i, j, 40, 40);
        }
      }

      // Draw door
      if (g.room.doorOpen) {
        ctx.fillStyle = '#44ff88';
        ctx.fillRect(375, 0, 50, 20);
        ctx.fillStyle = '#ffffff';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('EXIT', 400, 14);
      }

      // Draw items
      g.items.forEach(item => {
        if (item.collected) return;
        ctx.fillStyle = POWERUPS[item.type].color;
        ctx.shadowBlur = 15;
        ctx.shadowColor = POWERUPS[item.type].color;
        ctx.beginPath();
        ctx.arc(item.x, item.y, 12, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      });

      // Draw tears
      g.player.tears.forEach(t => {
        ctx.fillStyle = '#88ccff';
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#88ccff';
        ctx.beginPath();
        ctx.arc(t.x, t.y, t.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      });

      // Draw enemies
      g.enemies.forEach(e => {
        if (e.type === 'boss') {
          ctx.fillStyle = '#ff0044';
          ctx.shadowBlur = 20;
          ctx.shadowColor = '#ff0044';
        } else if (e.type === 'fast') {
          ctx.fillStyle = '#ffaa00';
        } else if (e.type === 'tank') {
          ctx.fillStyle = '#444444';
        } else if (e.type === 'projectile') {
          ctx.fillStyle = '#ff4444';
        } else {
          ctx.fillStyle = '#aa4444';
        }
        
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        if (e.type === 'boss') {
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(e.x - 30, e.y - 40, 60, 6);
          ctx.fillStyle = '#ff0044';
          ctx.fillRect(e.x - 30, e.y - 40, 60 * (e.hp / e.maxHp), 6);
        }
      });

      // Draw particles
      g.particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life / 20;
        ctx.fillRect(p.x, p.y, 3, 3);
        ctx.globalAlpha = 1;
      });

      // Draw player
      ctx.fillStyle = '#ffeeaa';
      ctx.shadowBlur = g.player.dashing > 0 ? 25 : 15;
      ctx.shadowColor = '#ffeeaa';
      ctx.globalAlpha = g.player.dashing > 0 ? 0.7 : 1;
      ctx.beginPath();
      ctx.arc(g.player.x, g.player.y, g.player.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;

      // Draw face
      ctx.fillStyle = '#000000';
      ctx.beginPath();
      ctx.arc(g.player.x - 6, g.player.y - 4, 3, 0, Math.PI * 2);
      ctx.arc(g.player.x + 6, g.player.y - 4, 3, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(g.player.x, g.player.y + 4, 6, 0, Math.PI);
      ctx.stroke();

      // Draw shoot direction
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(g.player.x, g.player.y);
      ctx.lineTo(g.player.x + g.shootDir.x * 30, g.player.y + g.shootDir.y * 30);
      ctx.stroke();

      if (g.shake > 0) ctx.restore();

      // Check if near exit door
      const nearDoor = g.room.doorOpen && g.player.y < 50 && g.player.x > 350 && g.player.x < 450;
      
      // Draw "Press E" prompt
      if (nearDoor) {
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Press E to Enter', 400, 60);
      }
      
      // Check exit collision with E key
      if (nearDoor && g.keys['e']) {
        g.keys['e'] = false; // Prevent multiple triggers
        
        if (g.room.type === 'boss' && g.bossDefeated) {
          setFloor(f => f + 1);
          setTimeout(() => {
            g.player.x = 400;
            g.player.y = 500;
            generateRoom('normal');
          }, 0);
        } else if (g.room.type === 'normal' && Math.random() < 0.25 + floor * 0.05) {
          setTimeout(() => {
            g.player.x = 400;
            g.player.y = 500;
            generateRoom('boss');
          }, 0);
        } else {
          setTimeout(() => {
            g.player.x = 400;
            g.player.y = 500;
            generateRoom('normal');
          }, 0);
        }
      }
    };

    const interval = setInterval(gameLoop, 1000 / 60);
    return () => {
      clearInterval(interval);
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [gameState, generateRoom, shoot, floor]);

  const startGame = () => {
    gameRef.current = {
      player: { x: 400, y: 300, hp: 6, maxHp: 6, speed: 3, damage: 1, fireRate: 15, size: 20, tears: [], powerups: [], dashCooldown: 0, dashing: 0 },
      enemies: [],
      items: [],
      particles: [],
      room: { cleared: false, type: 'normal', doorOpen: false },
      keys: {},
      frame: 0,
      cooldown: 0,
      shake: 0,
      bossDefeated: false,
      shootDir: { x: 0, y: -1 }
    };
    setScore(0);
    setFloor(1);
    generateRoom('normal');
    setGameState('playing');
  };

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-b from-purple-900 to-black p-4">
      <div className="mb-4 flex gap-4 items-center">
        <div className="flex items-center gap-2 bg-black/50 px-4 py-2 rounded">
          <Heart className="text-red-500" size={20} />
          <span className="text-white font-bold">
            {gameState === 'playing' ? gameRef.current.player.hp : 6}/{gameState === 'playing' ? gameRef.current.player.maxHp : 6}
          </span>
        </div>
        <div className="flex items-center gap-2 bg-black/50 px-4 py-2 rounded">
          <TrendingUp className="text-yellow-500" size={20} />
          <span className="text-white font-bold">Floor: {floor}</span>
        </div>
        <div className="flex items-center gap-2 bg-black/50 px-4 py-2 rounded">
          <Zap className="text-blue-500" size={20} />
          <span className="text-white font-bold">Score: {score}</span>
        </div>
      </div>

      <div className="relative">
        <canvas
          ref={canvasRef}
          width={800}
          height={600}
          className="border-4 border-purple-500 rounded-lg shadow-2xl"
        />
        
        {gameState === 'menu' && (
          <div className="absolute inset-0 flex flex-col items-center justify-center bg-black/80 rounded-lg">
            <h1 className="text-6xl font-bold text-white mb-8">Dungeon Descent</h1>
            <button
              onClick={startGame}
              className="px-8 py-4 bg-purple-600 hover:bg-purple-700 text-white text-2xl font-bold rounded-lg transition-colors"
            >
              Start Game
            </button>
            <div className="mt-8 text-white text-center">
              <p className="mb-2">WASD - Move</p>
              <p className="mb-2">Arrow Keys - Shoot</p>
              <p className="mb-2">Spacebar - Dash</p>
              <p className="mb-2">E - Enter Door</p>
              <p>Clear rooms and defeat bosses!</p>
            </div>
          </div>
        )}

        {gameState === 'gameover' && (
          <div className="absolute inset-0 flex flex-col items-center justify-center bg-black/80 rounded-lg">
            <h1 className="text-6xl font-bold text-red-500 mb-4">Game Over</h1>
            <p className="text-white text-2xl mb-2">Floor Reached: {floor}</p>
            <p className="text-white text-2xl mb-8">Score: {score}</p>
            <button
              onClick={startGame}
              className="px-8 py-4 bg-purple-600 hover:bg-purple-700 text-white text-2xl font-bold rounded-lg transition-colors"
            >
              Try Again
            </button>
          </div>
        )}
      </div>

      {gameState === 'playing' && (
        <div className="mt-4 grid grid-cols-5 gap-2">
          {gameRef.current.player.powerups.map((p, i) => (
            <div key={i} className="bg-black/50 px-3 py-1 rounded text-white text-sm">
              {POWERUPS[p]?.name || 'Triple Shot'}
            </div>
          ))}
        </div>
      )}
    </div>
  );
};

export default DungeonDescent;
